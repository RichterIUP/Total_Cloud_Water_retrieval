#!/usr/bin/python
'''@package docstring
Control variables for the retrieval
'''
import os
import numpy as np

# File format of input
FORMAT = 'NC'

LAT = 78.92
LON = 11.92

# Path to the output of TCWret
PATH = os.getcwd() + '/OUTFOLDER'
RESULTS = os.getcwd() + '/RESULTS'

# Path to the binary of LBLRTM
PATH_TO_LBLRTM = "/home/phi.richter/radiative_transfer/lblrtm"
PATH_TO_RUN_LBLRTM = "/mnt/beegfs/user/phi.richter/run_LBLRTM"

# Path to the binary of LBLDIS
PATH_TO_LBLDIS = "/home/phi.richter/radiative_transfer/lbldis"

# Path to the source of TCWret
PATH_TO_TCWRET = "/mnt/beegfs/user/phi.richter/Total_Cloud_Water_retrieval_conv_change_2"

# Path to ftsreader
PATH_TO_FTSREADER = "/mnt/beegfs/user/phi.richter/ftsreader"

# Microwindows used by TCWret
WINDOWS = "/mnt/beegfs/user/phi.richter/Total_Cloud_Water_retrieval/microwindows/high_snr_polarstern"


# Resolution of the spectrum in cm-1. Calculate convolution according to the resolution
RESOLUTION = 0.3
CONVOLUTION = True

# Initial parameter mu for the Levenberg-Marquardt-Algorithm.
LM_INIT = 1e2
INCREASE_LM = 4.0
DECREASE_LM = 2.0

# Minimum value for mu. The parameter won't go below this value.
LM_MIN = 0.0

# Standard deviation of the measured spectral radiances. If STDDEV is below 
# 0, then the STDDEV is read from the spectrum file. If it equals 0, then
# a non-weighted least squares algorithm is run. Positive values let L-IWP ignore
# the value from the spectrum file. If a testcase is retrieved, then positive
# values are the standard deviation of the added noise
STDDEV = -1.0

# Use scattering in LBLDIS?
SCATTER = True


# Disturb the temperature, absolute value (K)
DISTURB_CTEMPERATURE = 0.0

# Disturb the humidity relative to the value from the radiosonde
SCALE_HUMIDITY = 1.0

#Add an offset to the spectrum (mW/[sr * m2 * cm-1])
OFFSET = -0.0

KURUCZ = "/mnt/beegfs/user/phi.richter/solar/solar.kurucz.rad.1cm-1binned.full_disk.asc"

DATABASES = ['/mnt/beegfs/user/phi.richter/ssp_database/ssp_db.mie_wat.gamma_sigma_0p100', \
'/mnt/beegfs/user/phi.richter/ssp_database/ssp_db.Droxtal.gamma.0p100']
TEMP_DATABASES  = [[233.15, 500.15], [0.0, 273.15]]

# Optical depths
TAU = [0.25, 0.25]

# Effective Droplet Radii
REFF = [np.log(5.), np.log(20.)]
LOG = True

MCP = np.array(TAU[:]+REFF[:])

# The a priori for the optimal estimation inversion. By default, the a priori equals the first guess MCP
MCP_APRIORI = MCP[:]

# The variance of the a priori and its weighting. This will be converted to the S_A matrix

VARIANCE_APRIORI_TAU = [0.04, 0.04]
VARIANCE_APRIORI_REFF = [np.log(100.0)**(-2), np.log(100.0)**(-2)]

VARIANCE_APRIORI = np.array(VARIANCE_APRIORI_TAU[:] + VARIANCE_APRIORI_REFF[:])

# Manual choise of the cloud thresholds (in m). If TCWret should use the cloud thresholds from the file, these have to be set to None
CLOUD_LAYERS = None

# If multiple layers available, only use cloud base height or cloud top height
ONLY_CLOUD_BASE = False
ONLY_CLOUD_TOP = False

# Surface emissivity: [wavenumber, emissivity] 
EMISSIVITY = [[100., 0.98], [700., 0.98], [800., 0.98], [3000, 0.98]]

# Maximum number of iterations
MAX_ITER = 30

# Stop iteration if change of cost function is less than CONVERGENCE
CONVERGENCE = 1e-3

path_tg = "/mnt/beegfs/user/phi.richter/Total_Cloud_Water_retrieval/trace_gases/"
CO2_FILE = path_tg + "co2.csv"
CO_FILE = path_tg + "co.csv"
CH4_FILE = path_tg + "ch4.csv"
N2O_FILE = path_tg + "n2o.csv"
O3_FILE = path_tg + "o3.csv"
O2_FILE = path_tg + "o2.csv"
HEIGHT_FILE = path_tg + "z.csv"

# Maximum allowed effective droplet radius
MAX_REFF = np.log(100.0)

# Minimum allowed effective droplet radius
MIN_REFF = np.log(1.0)

RECALIBRATE = False
FILE_EMISS = "/home/phi.richter/Data/PASCAL_SiPCA_FRAM_2017/bb_emissivity.csv"
FILE_TEMP = "/home/phi.richter/Data/PASCAL_SiPCA_FRAM_2017/temperature_lab.csv"


ALTITUDE_GRID = "/mnt/beegfs/user/phi.richter/Total_Cloud_Water_retrieval/grids/red_grid"

KEY_RH = "r"
KEY_TEMP= "t"
KEY_HEIGHT = "z"
TIME_UNIT = [1900, 3600]
